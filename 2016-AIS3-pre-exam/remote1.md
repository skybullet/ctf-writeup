# remote1
Author: HaopingKu  
date: July 14, 2016

we are given a binary file `remote1`. by executing it, we get
```
Enter passcode: 123
Incorrect passcode!
```
First we can get assembly code by using `objdump`, please see [here](https://github.com/skybullet/ctf-writeup/blob/master/2016-AIS3-pre-exam/remote1-objdump).
Here is what it does:
* `400908: mov    $0x0,%edi`  
  `40090d: callq  4007d0 <time@plt>`  
  `400912: mov    %eax,%edi`  
  `400914: callq  400790 <srand@plt>`  
  `400919: callq  4007f0 <rand@plt>` get a random number, same as `int rand_n = srand(time(NULL));`
* `40096a: callq 400770 <printf@plt>` print "Enter passcode: "
* `400985: callq 4007a0 <fgets@plt>` read a string using
* `4009ad: callq 4007c0 <strtol@plt>` change the string into int
* `4009c4: xor %edx,%eax` xor input number to random number
* `4009c6: cmp $0x2016a153,%eax`  
  `4009cb: jne 400a17 <main+0x12a>` compare to 0x2016a153

It seems difficult to guess the correct random number in remote machine, but we know the seed, which is time(NULL). The sequence of random number will be the same if it's generated by the same random algorithm with same seed. We can write a C code doing same thing, because 0x2016a153 equals (rand xor (rand xor 0x2016a153)), so our input becomes (rand xor 0x2016a153).

In our C code, we have the seed that is initialized by time(NULL) + 60, that is, 1 minute after.
```c
// run.c
#include <stdio.h>
int main(){
    int i, r;
    char s[100];
    srand(time(NULL) + 60);
    r = rand() ^ 0x2016a153;
    for(i = 0; i < 20; i++){
        sprintf(s, "echo %d | nc quiz.ais3.org 2154", r);
        system(s);
        usleep(900000);
    }
}
```
```bash
$ gcc -o run run.c
$ ./run
```
wait for about 60 seconds, and flag get!

if 1 minute is not enough, add it yourself :)

notice: random algorithm varies in different OS, remote machine is probably Ubuntu. I did this on Ubuntu 14.04.

